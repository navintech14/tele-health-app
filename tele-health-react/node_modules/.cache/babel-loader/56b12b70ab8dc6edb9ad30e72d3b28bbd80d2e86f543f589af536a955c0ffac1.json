{"ast":null,"code":"export default function encrypt(file, callback) {\n  const reader = new FileReader();\n  reader.readAsDataURL(file);\n  reader.onload = () => {\n    const image = new Image();\n    image.src = reader.result;\n    let key = \"\";\n    image.onload = () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(image, 0, 0);\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      const [encryptedImageData, key1] = scramble(imageData, (source, diff) => {\n        return leftRotate(source, diff);\n      }, true, key);\n      //const [encryptedImageDataFinal, key2] = encryptImageData1(encryptedImageData, key1);\n      ctx.putImageData(encryptedImageData, 0, 0);\n      canvas.toBlob(blob => {\n        callback([blob, key1]);\n      }, 'image/png');\n    };\n  };\n}\nexport function decrypt(file, decryptionKey) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const reader = new FileReader();\n    reader.onload = () => {\n      img.onload = () => {\n        console.log(\"Key value goten out of API call\" + decryptionKey);\n        const canvas = document.createElement('canvas');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n        //const decryptedImageData1 = decryptImageData1(imageData, decryptionKey);\n        //console.log(\"Key cal in decrypt function after decryptImageData1 call\" + decryptionKey);\n        const [decryptedImageDataFinal, key] = scramble(imageData, (source, diff) => {\n          return rightRotate(source, diff);\n        }, false, decryptionKey);\n        console.log(\"Key cal in decrypt function after scramble call\" + key);\n        imageData.data.set(decryptedImageDataFinal);\n        ctx.putImageData(imageData, 0, 0);\n        canvas.toBlob(blob => {\n          const decryptedFile = new File([blob], file.name, {\n            type: file.type\n          });\n          resolve(decryptedFile);\n        }, file.type);\n      };\n      img.src = reader.result;\n    };\n    reader.readAsDataURL(file);\n  });\n}\nfunction encryptImageData1(imageData, key) {\n  let x = getRandomValue1();\n  let r = getRandomValue2();\n  const rKey = r.toString().substring(r.toString().indexOf('.') + 1);\n  const xKey = x.toString().substring(x.toString().indexOf('.') + 1);\n  key += String(xKey);\n  key += String(rKey);\n  for (let i = 0; i < imageData.data.length; i++) {\n    x = r * x * (1 - x);\n    imageData.data[i] ^= Math.floor(x * 256);\n  }\n  return [imageData, key];\n}\nfunction decryptImageData1(encryptedImageData, key) {\n  console.log(\"Key value passed to decryptImageData1\" + key);\n  let x = key.slice(256, 264);\n  x = Number(parseFloat(\"0.\" + x));\n  console.log(\"X value\" + x);\n  let r = key.slice(264, 272);\n  r = Number(parseFloat(\"3.\" + r));\n  console.log(\"r value\" + r);\n  for (let i = 0; i < encryptedImageData.data.length; i++) {\n    x = r * x * (1 - x);\n    encryptedImageData.data[i] ^= Math.floor(x * 256);\n  }\n  return encryptedImageData;\n}\nfunction getRandomValue1() {\n  const allowedChars = '0123456789';\n  let randomString = '';\n  for (let i = 0; i < 8; i++) {\n    const randomIndex = Math.floor(Math.random() * allowedChars.length);\n    randomString += allowedChars[randomIndex];\n  }\n  return `0.${randomString}`;\n}\nfunction getRandomValue2() {\n  const allowedChars = '0123456789';\n  let randomString = '';\n  for (let i = 0; i < 7; i++) {\n    const randomIndex = Math.floor(Math.random() * allowedChars.length);\n    randomString += allowedChars[randomIndex];\n  }\n  return `3.7${randomString}`;\n}\nfunction getRandomValue3() {\n  const length = 256;\n  const allowedChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let randomString = '';\n  for (let i = 0; i < 256; i++) {\n    const randomIndex = Math.floor(Math.random() * allowedChars.length);\n    randomString += allowedChars[randomIndex];\n  }\n  return randomString;\n}\nfunction scramble(imageData, rotateFunction, isEncrypt, key) {\n  let rand;\n  if (isEncrypt) {\n    rand = getRandomValue3();\n    key += rand;\n  }\n  if (!isEncrypt) {\n    rand = key.slice(0, 256);\n  }\n  console.log(\"key value in scramble\" + key);\n  console.log(\"Rand key value in scramble\" + rand);\n  let random = new Math.seedrandom(rand);\n  let max = 257;\n  let min = 0;\n  for (let index = 0; index < imageData.data.length / 4; index++) {\n    let randomNum = () => Math.floor(random() * (max - min)) + min;\n    let colorData = getPixel(imageData, index);\n    colorData[0] = rotateFunction(colorData[0], randomNum());\n    colorData[1] = rotateFunction(colorData[1], randomNum());\n    colorData[2] = rotateFunction(colorData[2], randomNum());\n    setPixelXY(imageData, Math.floor(index % imageData.width), Math.floor(index / imageData.width), colorData[0], colorData[1], colorData[2], 255);\n  }\n  return [imageData, key];\n}\nfunction rightRotate(source, diff) {\n  let circleSize = 256;\n  let rotatedVal = (source + diff) % circleSize;\n  if (rotatedVal < 0 || rotatedVal > 255) {\n    alert(\"wrong\");\n  }\n  return (source + diff) % circleSize;\n}\nfunction leftRotate(source, diff) {\n  let circleSize = 256;\n  if (source >= diff) {\n    return source - diff;\n  } else {\n    return circleSize - (diff - source);\n  }\n}\nfunction getPixel(imgData, index) {\n  var i = index * 4,\n    d = imgData.data;\n  return [d[i], d[i + 1], d[i + 2], d[i + 3]];\n}\nfunction getPixelXY(imgData, x, y) {\n  return getPixel(imgData, y * imgData.width + x);\n}\nfunction setPixel(imgData, index, r, g, b, a) {\n  var i = index * 4,\n    d = imgData.data;\n  d[i] = r;\n  d[i + 1] = g;\n  d[i + 2] = b;\n  d[i + 3] = a;\n}\nfunction setPixelXY(imgData, x, y, r, g, b, a) {\n  return setPixel(imgData, y * imgData.width + x, r, g, b, a);\n}\nfunction encryptImageRook(image) {\n  var height = image.height;\n  var width = image.width;\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      var steps = Math.floor(Math.random() * (width - x));\n      var direction = Math.random() < 0.5 ? -1 : 1;\n      var currentX = x;\n      var currentY = y;\n      for (var i = 0; i < steps; i++) {\n        if (direction < 0) {\n          currentX--;\n          if (currentX < 0) {\n            currentX = width - 1;\n          }\n        } else {\n          currentX++;\n          if (currentX >= width) {\n            currentX = 0;\n          }\n        }\n        var temp = image.data[(currentY * width + currentX) * 4];\n        image.data[(currentY * width + currentX) * 4] = image.data[(y * width + x) * 4];\n        image.data[(y * width + x) * 4] = temp;\n      }\n    }\n  }\n  return image;\n}\nfunction decryptImageRook(image) {\n  var height = image.height;\n  var width = image.width;\n\n  // Loop through each pixel in the image (in reverse order)\n  for (var y = height - 1; y >= 0; y--) {\n    for (var x = width - 1; x >= 0; x--) {\n      // Generate the same number of steps and direction as in the encryption process\n      var steps = Math.floor(Math.random() * (width - x));\n      var direction = Math.random() < 0.5 ? -1 : 1;\n\n      // Move the rook and swap the pixels (in reverse order)\n      var currentX = x;\n      var currentY = y;\n      for (var i = 0; i < steps; i++) {\n        if (direction < 0) {\n          currentX--;\n          if (currentX < 0) {\n            currentX = width - 1;\n          }\n        } else {\n          currentX++;\n          if (currentX >= width) {\n            currentX = 0;\n          }\n        }\n        var temp = image.data[(currentY * width + currentX) * 4];\n        image.data[(currentY * width + currentX) * 4] = image.data[(y * width + x) * 4];\n        image.data[(y * width + x) * 4] = temp;\n      }\n    }\n  }\n  return image;\n}\nfunction encryptImage(image) {\n  var height = image.height;\n  var width = image.width;\n\n  // Loop through each pixel in the image\n  for (var y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++) {\n      // Generate a random number of steps and direction for both the queen's vertical and horizontal movement\n      var stepsX = Math.floor(Math.random() * (width - x));\n      var directionX = Math.random() < 0.5 ? -1 : 1;\n      var stepsY = Math.floor(Math.random() * (height - y));\n      var directionY = Math.random() < 0.5 ? -1 : 1;\n\n      // Move the queen and swap the pixels\n      var currentX = x;\n      var currentY = y;\n      for (var i = 0; i < Math.max(stepsX, stepsY); i++) {\n        if (i < stepsX) {\n          currentX += directionX;\n          if (currentX < 0) {\n            currentX = width - 1;\n          } else if (currentX >= width) {\n            currentX = 0;\n          }\n        }\n        if (i < stepsY) {\n          currentY += directionY;\n          if (currentY < 0) {\n            currentY = height - 1;\n          } else if (currentY >= height) {\n            currentY = 0;\n          }\n        }\n        var temp = image.data[(currentY * width + currentX) * 4];\n        image.data[(currentY * width + currentX) * 4] = image.data[(y * width + x) * 4];\n        image.data[(y * width + x) * 4] = temp;\n      }\n    }\n  }\n  return image;\n}\nfunction decryptImage(image) {\n  var height = image.height;\n  var width = image.width;\n\n  // Loop through each pixel in the image (in reverse order)\n  for (var y = height - 1; y >= 0; y--) {\n    for (var x = width - 1; x >= 0; x--) {\n      // Generate the same number of steps and direction for both the queen's vertical and horizontal movement as in the encryption process\n      var stepsX = Math.floor(Math.random() * (width - x));\n      var directionX = Math.random() < 0.5 ? -1 : 1;\n      var stepsY = Math.floor(Math.random() * (height - y));\n      var directionY = Math.random() < 0.5 ? -1 : 1;\n\n      // Move the queen and swap the pixels (in reverse order)\n      var currentX = x;\n      var currentY = y;\n      for (var i = 0; i < Math.max(stepsX, stepsY); i++) {\n        if (i < stepsX) {\n          currentX += directionX;\n          if (currentX < 0) {\n            currentX = width - 1;\n          } else if (currentX >= width) {\n            currentX = 0;\n          }\n        }\n        if (i < stepsY) {\n          currentY += directionY;\n          if (currentY < 0) {\n            currentY = height - 1;\n          } else if (currentY >= height) {\n            currentY = 0;\n          }\n        }\n        var temp = image.data[(currentY * width + currentX) * 4];\n        image.data[(currentY * width + currentX) * 4] = image.data[(y * width + x) * 4];\n        image.data[(y * width + x) * 4] = temp;\n      }\n    }\n  }\n  return image;\n}","map":{"version":3,"names":["encrypt","file","callback","reader","FileReader","readAsDataURL","onload","image","Image","src","result","key","canvas","document","createElement","width","height","ctx","getContext","drawImage","imageData","getImageData","encryptedImageData","key1","scramble","source","diff","leftRotate","putImageData","toBlob","blob","decrypt","decryptionKey","Promise","resolve","reject","img","console","log","decryptedImageDataFinal","rightRotate","data","set","decryptedFile","File","name","type","encryptImageData1","x","getRandomValue1","r","getRandomValue2","rKey","toString","substring","indexOf","xKey","String","i","length","Math","floor","decryptImageData1","slice","Number","parseFloat","allowedChars","randomString","randomIndex","random","getRandomValue3","rotateFunction","isEncrypt","rand","seedrandom","max","min","index","randomNum","colorData","getPixel","setPixelXY","circleSize","rotatedVal","alert","imgData","d","getPixelXY","y","setPixel","g","b","a","encryptImageRook","steps","direction","currentX","currentY","temp","decryptImageRook","encryptImage","stepsX","directionX","stepsY","directionY","decryptImage"],"sources":["D:/tele-health/tele-health-react/src/encrypt.js"],"sourcesContent":["export default function encrypt(file, callback){\r\n    const reader = new FileReader();\r\n    reader.readAsDataURL(file);\r\n    reader.onload = () => {\r\n        const image = new Image();\r\n        image.src = reader.result;\r\n        let key = \"\";\r\n        image.onload = () => {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = image.width;\r\n            canvas.height = image.height;\r\n            const ctx = canvas.getContext('2d');\r\n            ctx.drawImage(image, 0, 0);\r\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n            const [encryptedImageData, key1] = scramble(imageData, (source, diff) => {\r\n                return leftRotate(source, diff);\r\n            }, true, key)\r\n            //const [encryptedImageDataFinal, key2] = encryptImageData1(encryptedImageData, key1);\r\n            ctx.putImageData(encryptedImageData, 0, 0);\r\n\r\n            canvas.toBlob((blob) => {\r\n                callback([blob, key1]);\r\n              }, 'image/png');\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function decrypt(file, decryptionKey){ \r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        const reader = new FileReader();\r\n        reader.onload = () => {\r\n            img.onload = () => {\r\n                console.log(\"Key value goten out of API call\" + decryptionKey);\r\n                const canvas = document.createElement('canvas');\r\n                canvas.width = img.width;\r\n                canvas.height = img.height;\r\n                const ctx = canvas.getContext('2d');\r\n                ctx.drawImage(img, 0, 0);\r\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n\r\n\r\n                //const decryptedImageData1 = decryptImageData1(imageData, decryptionKey);\r\n                //console.log(\"Key cal in decrypt function after decryptImageData1 call\" + decryptionKey);\r\n                const [decryptedImageDataFinal, key] = scramble(imageData, (source, diff) => {\r\n                    return rightRotate(source, diff);\r\n                }, false, decryptionKey)\r\n                console.log(\"Key cal in decrypt function after scramble call\" + key);\r\n\r\n\r\n                imageData.data.set(decryptedImageDataFinal);\r\n                ctx.putImageData(imageData, 0, 0);\r\n                canvas.toBlob((blob) => {\r\n                    const decryptedFile = new File([blob], file.name, { type: file.type });\r\n                    resolve(decryptedFile);\r\n                  }, file.type);\r\n                };\r\n                img.src = reader.result;\r\n                };\r\n                reader.readAsDataURL(file);\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction encryptImageData1(imageData, key) {\r\n    let x = getRandomValue1(); \r\n    let r = getRandomValue2(); \r\n    const rKey = r.toString().substring(r.toString().indexOf('.') + 1);\r\n    const xKey = x.toString().substring(x.toString().indexOf('.') + 1);\r\n    key += String(xKey);\r\n    key += String(rKey);\r\n    for (let i = 0; i < imageData.data.length; i++) {\r\n      x = r * x * (1 - x); \r\n      imageData.data[i] ^= Math.floor(x * 256);\r\n    }\r\n    return [imageData, key];\r\n}\r\n\r\n\r\nfunction decryptImageData1(encryptedImageData, key) {\r\n    console.log(\"Key value passed to decryptImageData1\" + key);\r\n    let x = key.slice(256, 264);\r\n    x = Number(parseFloat(\"0.\" + x));\r\n    console.log(\"X value\" + x);\r\n    let r = key.slice(264, 272);\r\n    r = Number(parseFloat(\"3.\" + r));\r\n    console.log(\"r value\" + r);\r\n    for (let i = 0; i < encryptedImageData.data.length; i++) {\r\n      x = r * x * (1 - x);\r\n      encryptedImageData.data[i] ^= Math.floor(x * 256); \r\n    }\r\n    return encryptedImageData;\r\n}\r\n\r\n\r\nfunction getRandomValue1() {\r\n    const allowedChars = '0123456789';\r\n\r\n    let randomString = '';\r\n    for (let i = 0; i < 8; i++) {\r\n        const randomIndex = Math.floor(Math.random() * allowedChars.length);\r\n        randomString += allowedChars[randomIndex];\r\n    }\r\n    return `0.${randomString}`;\r\n}\r\n\r\nfunction getRandomValue2() {\r\n    const allowedChars = '0123456789';\r\n\r\n    let randomString = '';\r\n    for (let i = 0; i < 7; i++) {\r\n        const randomIndex = Math.floor(Math.random() * allowedChars.length);\r\n        randomString += allowedChars[randomIndex];\r\n    }\r\n    return `3.7${randomString}`;\r\n}\r\n\r\n\r\nfunction getRandomValue3() {\r\n    const length = 256;\r\n\r\n    const allowedChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n\r\n    let randomString = '';\r\n    for (let i = 0; i < 256; i++) {\r\n        const randomIndex = Math.floor(Math.random() * allowedChars.length);\r\n        randomString += allowedChars[randomIndex];\r\n    }\r\n    return randomString;\r\n}\r\n\r\n\r\nfunction scramble(imageData, rotateFunction, isEncrypt, key) {\r\n    let rand;\r\n    if(isEncrypt)\r\n    {\r\n        rand = getRandomValue3();\r\n        key += rand;\r\n    }\r\n    if(!isEncrypt)\r\n    {\r\n        rand = key.slice(0, 256);\r\n    }\r\n    console.log(\"key value in scramble\" + key)\r\n    console.log(\"Rand key value in scramble\" + rand)\r\n    let random = new Math.seedrandom(rand);\r\n    let max = 257;\r\n    let min = 0;\r\n    for (let index = 0; index < imageData.data.length / 4; index++) {\r\n        let randomNum = () => Math.floor(random() * (max - min)) + min;\r\n        let colorData = getPixel(imageData, index);\r\n        colorData[0] = rotateFunction(colorData[0], randomNum());\r\n        colorData[1] = rotateFunction(colorData[1], randomNum());\r\n        colorData[2] = rotateFunction(colorData[2], randomNum());\r\n        setPixelXY(imageData, Math.floor(index % imageData.width), Math.floor(index / imageData.width), colorData[0], colorData[1], colorData[2], 255);\r\n    }\r\n    return [imageData, key];\r\n}\r\n\r\n\r\nfunction rightRotate(source, diff) {\r\n    let circleSize = 256;\r\n    let rotatedVal = (source + diff) % circleSize;\r\n    if (rotatedVal < 0 || rotatedVal > 255) {\r\n        alert(\"wrong\");\r\n    }\r\n    return (source + diff) % circleSize;\r\n}\r\n\r\nfunction leftRotate(source, diff) {\r\n    let circleSize = 256;\r\n    if (source >= diff) {\r\n        return source - diff;\r\n    }\r\n    else {\r\n        return circleSize - (diff - source);\r\n    }\r\n}\r\n\r\n\r\nfunction getPixel(imgData, index) {\r\n    var i = index * 4, d = imgData.data;\r\n    return [d[i], d[i + 1], d[i + 2], d[i + 3]]\r\n}\r\n\r\nfunction getPixelXY(imgData, x, y) {\r\n    return getPixel(imgData, y * imgData.width + x);\r\n}\r\n\r\nfunction setPixel(imgData, index, r, g, b, a) {\r\n    var i = index * 4, d = imgData.data;\r\n    d[i] = r;\r\n    d[i + 1] = g;\r\n    d[i + 2] = b;\r\n    d[i + 3] = a;\r\n}\r\n\r\nfunction setPixelXY(imgData, x, y, r, g, b, a) {\r\n    return setPixel(imgData, y * imgData.width + x, r, g, b, a);\r\n}\r\n\r\n\r\nfunction encryptImageRook(image) {\r\n    var height = image.height;\r\n    var width = image.width;\r\n  \r\n    for (var y = 0; y < height; y++) {\r\n      for (var x = 0; x < width; x++) {\r\n        var steps = Math.floor(Math.random() * (width - x));\r\n        var direction = Math.random() < 0.5 ? -1 : 1;\r\n  \r\n        var currentX = x;\r\n        var currentY = y;\r\n        for (var i = 0; i < steps; i++) {\r\n          if (direction < 0) {\r\n            currentX--;\r\n            if (currentX < 0) {\r\n              currentX = width - 1;\r\n            }\r\n          } else {\r\n            currentX++;\r\n            if (currentX >= width) {\r\n              currentX = 0;\r\n            }\r\n          }\r\n          var temp = image.data[(currentY * width + currentX) * 4];\r\n          image.data[(currentY * width + currentX) * 4] = image.data[(y * width + x) * 4];\r\n          image.data[(y * width + x) * 4] = temp;\r\n        }\r\n      }\r\n    }\r\n  \r\n    return image;\r\n  }\r\n  \r\n\r\n  function decryptImageRook(image) {\r\n    var height = image.height;\r\n    var width = image.width;\r\n  \r\n    // Loop through each pixel in the image (in reverse order)\r\n    for (var y = height - 1; y >= 0; y--) {\r\n      for (var x = width - 1; x >= 0; x--) {\r\n        // Generate the same number of steps and direction as in the encryption process\r\n        var steps = Math.floor(Math.random() * (width - x));\r\n        var direction = Math.random() < 0.5 ? -1 : 1;\r\n  \r\n        // Move the rook and swap the pixels (in reverse order)\r\n        var currentX = x;\r\n        var currentY = y;\r\n        for (var i = 0; i < steps; i++) {\r\n          if (direction < 0) {\r\n            currentX--;\r\n            if (currentX < 0) {\r\n              currentX = width - 1;\r\n            }\r\n          } else {\r\n            currentX++;\r\n            if (currentX >= width) {\r\n              currentX = 0;\r\n            }\r\n          }\r\n          var temp = image.data[(currentY * width + currentX) * 4];\r\n          image.data[(currentY * width + currentX) * 4] = image.data[(y * width + x) * 4];\r\n          image.data[(y * width + x) * 4] = temp;\r\n        }\r\n      }\r\n    }\r\n  \r\n    return image;\r\n  }\r\n\r\n\r\n  function encryptImage(image) {\r\n    var height = image.height;\r\n    var width = image.width;\r\n  \r\n    // Loop through each pixel in the image\r\n    for (var y = 0; y < height; y++) {\r\n      for (var x = 0; x < width; x++) {\r\n        // Generate a random number of steps and direction for both the queen's vertical and horizontal movement\r\n        var stepsX = Math.floor(Math.random() * (width - x));\r\n        var directionX = Math.random() < 0.5 ? -1 : 1;\r\n        var stepsY = Math.floor(Math.random() * (height - y));\r\n        var directionY = Math.random() < 0.5 ? -1 : 1;\r\n  \r\n        // Move the queen and swap the pixels\r\n        var currentX = x;\r\n        var currentY = y;\r\n        for (var i = 0; i < Math.max(stepsX, stepsY); i++) {\r\n          if (i < stepsX) {\r\n            currentX += directionX;\r\n            if (currentX < 0) {\r\n              currentX = width - 1;\r\n            } else if (currentX >= width) {\r\n              currentX = 0;\r\n            }\r\n          }\r\n          if (i < stepsY) {\r\n            currentY += directionY;\r\n            if (currentY < 0) {\r\n              currentY = height - 1;\r\n            } else if (currentY >= height) {\r\n              currentY = 0;\r\n            }\r\n          }\r\n          var temp = image.data[(currentY * width + currentX) * 4];\r\n          image.data[(currentY * width + currentX) * 4] = image.data[(y * width + x) * 4];\r\n          image.data[(y * width + x) * 4] = temp;\r\n        }\r\n      }\r\n    }\r\n  \r\n    return image;\r\n  }\r\n  \r\n  function decryptImage(image) {\r\n    var height = image.height;\r\n    var width = image.width;\r\n  \r\n    // Loop through each pixel in the image (in reverse order)\r\n    for (var y = height - 1; y >= 0; y--) {\r\n      for (var x = width - 1; x >= 0; x--) {\r\n        // Generate the same number of steps and direction for both the queen's vertical and horizontal movement as in the encryption process\r\n        var stepsX = Math.floor(Math.random() * (width - x));\r\n        var directionX = Math.random() < 0.5 ? -1 : 1;\r\n        var stepsY = Math.floor(Math.random() * (height - y));\r\n        var directionY = Math.random() < 0.5 ? -1 : 1;\r\n  \r\n        // Move the queen and swap the pixels (in reverse order)\r\n        var currentX = x;\r\n        var currentY = y;\r\n        for (var i = 0; i < Math.max(stepsX, stepsY); i++) {\r\n          if (i < stepsX) {\r\n            currentX += directionX;\r\n            if (currentX < 0) {\r\n              currentX = width - 1;\r\n            } else if (currentX >= width) {\r\n              currentX = 0;\r\n            }\r\n          }\r\n          if (i < stepsY) {\r\n            currentY += directionY;\r\n            if (currentY < 0) {\r\n              currentY = height - 1;\r\n            } else if (currentY >= height) {\r\n              currentY = 0;\r\n            }\r\n          }\r\n          var temp = image.data[(currentY * width + currentX\r\n            ) * 4];\r\n            image.data[(currentY * width + currentX) * 4] = image.data[(y * width + x) * 4];\r\n            image.data[(y * width + x) * 4] = temp;\r\n            }\r\n            }\r\n            }\r\n            \r\n            return image;\r\n            }  \r\n  "],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}